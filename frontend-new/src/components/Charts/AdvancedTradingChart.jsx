import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport {\n  Box,\n  Card,\n  CardContent,\n  CardHeader,\n  Typography,\n  IconButton,\n  Button,\n  Menu,\n  MenuItem,\n  Tooltip,\n  Chip,\n  Switch,\n  FormControlLabel,\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  List,\n  ListItem,\n  ListItemIcon,\n  ListItemText,\n  ListItemSecondaryAction,\n  Divider,\n  Paper,\n  Grid,\n  Slider,\n  TextField,\n  FormControl,\n  InputLabel,\n  Select,\n  Checkbox,\n  useTheme,\n  alpha\n} from '@mui/material';\nimport {\n  MoreVert,\n  ZoomIn,\n  ZoomOut,\n  Fullscreen,\n  FullscreenExit,\n  Refresh,\n  Download,\n  Share,\n  Settings,\n  TrendingUp,\n  TrendingDown,\n  ShowChart,\n  BarChart,\n  Timeline,\n  CandlestickChart,\n  Insights,\n  Palette,\n  Visibility,\n  VisibilityOff,\n  Add,\n  Remove,\n  PlayArrow,\n  Pause,\n  SkipNext,\n  SkipPrevious\n} from '@mui/icons-material';\nimport {\n  LineChart,\n  Line,\n  AreaChart,\n  Area,\n  ResponsiveContainer,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip as RechartsTooltip,\n  Legend,\n  ComposedChart,\n  Bar,\n  ReferenceLine,\n  ReferenceArea,\n  Brush,\n  Cell\n} from 'recharts';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { format, subDays, addDays } from 'date-fns';\nimport { useSnackbar } from '../../contexts/SnackbarContext';\n\nconst AdvancedTradingChart = ({ \n  data = [], \n  symbol = 'NQ', \n  onTradeAnnotation,\n  onAnalysisUpdate,\n  height = 400,\n  showToolbar = true,\n  allowAnnotations = true\n}) => {\n  const theme = useTheme();\n  const { enqueueSnackbar } = useSnackbar();\n  const chartRef = useRef(null);\n  \n  // State management\n  const [chartType, setChartType] = useState('candlestick');\n  const [timeframe, setTimeframe] = useState('1H');\n  const [indicators, setIndicators] = useState({\n    sma20: false,\n    sma50: false,\n    ema20: false,\n    bollinger: false,\n    rsi: false,\n    macd: false,\n    volume: true,\n    support_resistance: true\n  });\n  const [overlays, setOverlays] = useState({\n    fibonacci: false,\n    trendlines: false,\n    channels: false,\n    supply_demand: false\n  });\n  const [chartSettings, setChartSettings] = useState({\n    gridLines: true,\n    crosshair: true,\n    priceScale: 'linear',\n    volumeHeight: 20,\n    colorScheme: 'professional'\n  });\n  const [fullscreen, setFullscreen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [indicatorsMenuAnchor, setIndicatorsMenuAnchor] = useState(null);\n  const [annotationMode, setAnnotationMode] = useState(null);\n  const [annotations, setAnnotations] = useState([]);\n  const [zoomLevel, setZoomLevel] = useState(1);\n  const [panPosition, setPanPosition] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1);\n  const [selectedArea, setSelectedArea] = useState(null);\n  \n  // Generate sample OHLCV data if none provided\n  useEffect(() => {\n    if (data.length === 0) {\n      generateSampleData();\n    }\n  }, [data.length]);\n  \n  const generateSampleData = () => {\n    // This would be replaced with real market data\n    const sampleData = Array.from({ length: 100 }, (_, i) => {\n      const date = subDays(new Date(), 99 - i);\n      const basePrice = 15000 + Math.sin(i / 10) * 200;\n      const volatility = 50;\n      \n      const open = basePrice + (Math.random() - 0.5) * volatility;\n      const high = open + Math.random() * volatility;\n      const low = open - Math.random() * volatility;\n      const close = low + Math.random() * (high - low);\n      const volume = Math.floor(Math.random() * 1000000) + 500000;\n      \n      return {\n        timestamp: date.getTime(),\n        date: format(date, 'MMM dd'),\n        open: parseFloat(open.toFixed(2)),\n        high: parseFloat(high.toFixed(2)),\n        low: parseFloat(low.toFixed(2)),\n        close: parseFloat(close.toFixed(2)),\n        volume,\n        // Technical indicators (would be calculated)\n        sma20: parseFloat((basePrice + Math.sin(i / 5) * 50).toFixed(2)),\n        sma50: parseFloat((basePrice + Math.sin(i / 15) * 30).toFixed(2)),\n        ema20: parseFloat((basePrice + Math.sin(i / 7) * 40).toFixed(2)),\n        rsi: 30 + Math.random() * 40,\n        macd: (Math.random() - 0.5) * 10,\n        signal: (Math.random() - 0.5) * 8\n      };\n    });\n    \n    return sampleData;\n  };\n  \n  const chartData = data.length > 0 ? data : generateSampleData();\n  \n  // Chart type configurations\n  const chartTypes = {\n    candlestick: {\n      name: 'Candlestick',\n      icon: <CandlestickChart />,\n      component: 'ComposedChart'\n    },\n    line: {\n      name: 'Line Chart',\n      icon: <ShowChart />,\n      component: 'LineChart'\n    },\n    area: {\n      name: 'Area Chart',\n      icon: <Timeline />,\n      component: 'AreaChart'\n    },\n    bar: {\n      name: 'Bar Chart',\n      icon: <BarChart />,\n      component: 'ComposedChart'\n    }\n  };\n  \n  // Technical indicators\n  const availableIndicators = {\n    sma20: { name: 'SMA 20', color: theme.palette.primary.main },\n    sma50: { name: 'SMA 50', color: theme.palette.secondary.main },\n    ema20: { name: 'EMA 20', color: theme.palette.success.main },\n    bollinger: { name: 'Bollinger Bands', color: theme.palette.info.main },\n    rsi: { name: 'RSI', color: theme.palette.warning.main, separate: true },\n    macd: { name: 'MACD', color: theme.palette.error.main, separate: true },\n    volume: { name: 'Volume', color: theme.palette.grey[500], separate: true },\n    support_resistance: { name: 'S/R Levels', color: theme.palette.purple?.main || '#9c27b0' }\n  };\n  \n  // Annotation tools\n  const annotationTools = [\n    { id: 'trendline', name: 'Trend Line', icon: <TrendingUp /> },\n    { id: 'horizontal', name: 'Horizontal Line', icon: <Remove /> },\n    { id: 'fibonacci', name: 'Fibonacci', icon: <Timeline /> },\n    { id: 'rectangle', name: 'Rectangle', icon: <CropFree /> },\n    { id: 'text', name: 'Text Note', icon: <TextFields /> }\n  ];\n  \n  const handleIndicatorToggle = (indicator) => {\n    setIndicators(prev => ({\n      ...prev,\n      [indicator]: !prev[indicator]\n    }));\n    \n    enqueueSnackbar(\n      `${availableIndicators[indicator].name} ${!indicators[indicator] ? 'enabled' : 'disabled'}`,\n      { variant: 'info' }\n    );\n  };\n  \n  const handleChartTypeChange = (type) => {\n    setChartType(type);\n    enqueueSnackbar(`Chart type changed to ${chartTypes[type].name}`, { variant: 'info' });\n  };\n  \n  const handleTimeframeChange = (tf) => {\n    setTimeframe(tf);\n    enqueueSnackbar(`Timeframe changed to ${tf}`, { variant: 'info' });\n  };\n  \n  const handleZoom = (direction) => {\n    const newZoom = direction === 'in' ? Math.min(zoomLevel * 1.2, 5) : Math.max(zoomLevel / 1.2, 0.2);\n    setZoomLevel(newZoom);\n  };\n  \n  const handleFullscreen = () => {\n    setFullscreen(!fullscreen);\n  };\n  \n  const handleExport = () => {\n    // Export chart as image or data\n    enqueueSnackbar('Chart exported successfully!', { variant: 'success' });\n  };\n  \n  const handleAnnotationClick = (tool) => {\n    setAnnotationMode(annotationMode === tool ? null : tool);\n  };\n  \n  const handleChartClick = (event) => {\n    if (!annotationMode || !allowAnnotations) return;\n    \n    // Add annotation based on current mode\n    const newAnnotation = {\n      id: Date.now(),\n      type: annotationMode,\n      x: event.activeLabel,\n      y: event.activePayload?.[0]?.payload?.close,\n      timestamp: new Date(),\n      note: annotationMode === 'text' ? 'New annotation' : null\n    };\n    \n    setAnnotations(prev => [...prev, newAnnotation]);\n    setAnnotationMode(null);\n    \n    if (onTradeAnnotation) {\n      onTradeAnnotation(newAnnotation);\n    }\n  };\n  \n  const renderCandlestickChart = () => {\n    const visibleData = chartData.slice(\n      Math.max(0, Math.floor(panPosition)),\n      Math.min(chartData.length, Math.floor(panPosition + chartData.length / zoomLevel))\n    );\n    \n    return (\n      <ResponsiveContainer width=\"100%\" height={height}>\n        <ComposedChart\n          data={visibleData}\n          margin={{ top: 20, right: 30, left: 20, bottom: 5 }}\n          onClick={handleChartClick}\n        >\n          {chartSettings.gridLines && <CartesianGrid strokeDasharray=\"3 3\" />}\n          <XAxis \n            dataKey=\"date\" \n            tick={{ fontSize: 12 }}\n            tickLine={false}\n          />\n          <YAxis \n            domain={['dataMin - 10', 'dataMax + 10']}\n            tick={{ fontSize: 12 }}\n            tickLine={false}\n          />\n          <RechartsTooltip\n            content={({ active, payload, label }) => {\n              if (active && payload && payload.length) {\n                const data = payload[0].payload;\n                return (\n                  <Paper sx={{ p: 2, maxWidth: 200 }}>\n                    <Typography variant=\"subtitle2\" sx={{ fontWeight: 'bold', mb: 1 }}>\n                      {label}\n                    </Typography>\n                    <Typography variant=\"body2\">O: {data.open}</Typography>\n                    <Typography variant=\"body2\">H: {data.high}</Typography>\n                    <Typography variant=\"body2\">L: {data.low}</Typography>\n                    <Typography variant=\"body2\">C: {data.close}</Typography>\n                    <Typography variant=\"body2\">V: {data.volume?.toLocaleString()}</Typography>\n                    \n                    {indicators.rsi && (\n                      <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                        RSI: {data.rsi?.toFixed(2)}\n                      </Typography>\n                    )}\n                  </Paper>\n                );\n              }\n              return null;\n            }}\n          />\n          \n          {/* Candlestick representation using bars */}\n          <Bar\n            dataKey={(entry) => [entry.low, entry.high]}\n            fill=\"transparent\"\n            stroke={theme.palette.text.primary}\n            strokeWidth={1}\n          />\n          \n          {/* Price line */}\n          <Line\n            type=\"monotone\"\n            dataKey=\"close\"\n            stroke={theme.palette.primary.main}\n            strokeWidth={2}\n            dot={false}\n            activeDot={{ r: 4 }}\n          />\n          \n          {/* Technical Indicators */}\n          {indicators.sma20 && (\n            <Line\n              type=\"monotone\"\n              dataKey=\"sma20\"\n              stroke={availableIndicators.sma20.color}\n              strokeWidth={1}\n              dot={false}\n              strokeDasharray=\"5 5\"\n            />\n          )}\n          \n          {indicators.sma50 && (\n            <Line\n              type=\"monotone\"\n              dataKey=\"sma50\"\n              stroke={availableIndicators.sma50.color}\n              strokeWidth={1}\n              dot={false}\n              strokeDasharray=\"3 3\"\n            />\n          )}\n          \n          {indicators.ema20 && (\n            <Line\n              type=\"monotone\"\n              dataKey=\"ema20\"\n              stroke={availableIndicators.ema20.color}\n              strokeWidth={1}\n              dot={false}\n            />\n          )}\n          \n          {/* Support/Resistance levels */}\n          {indicators.support_resistance && (\n            <>\n              <ReferenceLine y={15200} stroke={theme.palette.success.main} strokeDasharray=\"2 2\" />\n              <ReferenceLine y={14800} stroke={theme.palette.error.main} strokeDasharray=\"2 2\" />\n            </>\n          )}\n          \n          {/* Annotations */}\n          {annotations.map(annotation => {\n            if (annotation.type === 'horizontal') {\n              return (\n                <ReferenceLine\n                  key={annotation.id}\n                  y={annotation.y}\n                  stroke={theme.palette.warning.main}\n                  strokeDasharray=\"4 4\"\n                />\n              );\n            }\n            return null;\n          })}\n          \n          {/* Brush for navigation */}\n          <Brush\n            dataKey=\"date\"\n            height={30}\n            stroke={theme.palette.primary.main}\n            fill={alpha(theme.palette.primary.main, 0.1)}\n          />\n        </ComposedChart>\n      </ResponsiveContainer>\n    );\n  };\n  \n  const renderVolumeChart = () => {\n    if (!indicators.volume) return null;\n    \n    const visibleData = chartData.slice(\n      Math.max(0, Math.floor(panPosition)),\n      Math.min(chartData.length, Math.floor(panPosition + chartData.length / zoomLevel))\n    );\n    \n    return (\n      <Box sx={{ mt: 2 }}>\n        <Typography variant=\"subtitle2\" sx={{ mb: 1, fontWeight: 'bold' }}>\n          Volume\n        </Typography>\n        <ResponsiveContainer width=\"100%\" height={120}>\n          <ComposedChart data={visibleData}>\n            <CartesianGrid strokeDasharray=\"3 3\" />\n            <XAxis dataKey=\"date\" tick={{ fontSize: 10 }} />\n            <YAxis tick={{ fontSize: 10 }} />\n            <RechartsTooltip />\n            <Bar\n              dataKey=\"volume\"\n              fill={theme.palette.grey[500]}\n              opacity={0.7}\n            />\n          </ComposedChart>\n        </ResponsiveContainer>\n      </Box>\n    );\n  };\n  \n  const renderRSIChart = () => {\n    if (!indicators.rsi) return null;\n    \n    const visibleData = chartData.slice(\n      Math.max(0, Math.floor(panPosition)),\n      Math.min(chartData.length, Math.floor(panPosition + chartData.length / zoomLevel))\n    );\n    \n    return (\n      <Box sx={{ mt: 2 }}>\n        <Typography variant=\"subtitle2\" sx={{ mb: 1, fontWeight: 'bold' }}>\n          RSI (14)\n        </Typography>\n        <ResponsiveContainer width=\"100%\" height={120}>\n          <ComposedChart data={visibleData}>\n            <CartesianGrid strokeDasharray=\"3 3\" />\n            <XAxis dataKey=\"date\" tick={{ fontSize: 10 }} />\n            <YAxis domain={[0, 100]} tick={{ fontSize: 10 }} />\n            <RechartsTooltip />\n            <Line\n              type=\"monotone\"\n              dataKey=\"rsi\"\n              stroke={availableIndicators.rsi.color}\n              strokeWidth={2}\n              dot={false}\n            />\n            <ReferenceLine y={70} stroke={theme.palette.error.main} strokeDasharray=\"2 2\" />\n            <ReferenceLine y={30} stroke={theme.palette.success.main} strokeDasharray=\"2 2\" />\n          </ComposedChart>\n        </ResponsiveContainer>\n      </Box>\n    );\n  };\n  \n  const renderToolbar = () => {\n    if (!showToolbar) return null;\n    \n    return (\n      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, p: 2, borderBottom: `1px solid ${theme.palette.divider}` }}>\n        {/* Symbol and Timeframe */}\n        <Chip label={symbol} color=\"primary\" sx={{ fontWeight: 'bold' }} />\n        \n        <Box sx={{ display: 'flex', gap: 0.5 }}>\n          {['1m', '5m', '15m', '1H', '4H', '1D'].map(tf => (\n            <Button\n              key={tf}\n              size=\"small\"\n              variant={timeframe === tf ? 'contained' : 'outlined'}\n              onClick={() => handleTimeframeChange(tf)}\n              sx={{ minWidth: 40, fontSize: '0.75rem' }}\n            >\n              {tf}\n            </Button>\n          ))}\n        </Box>\n        \n        <Divider orientation=\"vertical\" flexItem />\n        \n        {/* Chart Types */}\n        <Box sx={{ display: 'flex', gap: 0.5 }}>\n          {Object.entries(chartTypes).map(([type, config]) => (\n            <Tooltip key={type} title={config.name}>\n              <IconButton\n                size=\"small\"\n                color={chartType === type ? 'primary' : 'default'}\n                onClick={() => handleChartTypeChange(type)}\n              >\n                {config.icon}\n              </IconButton>\n            </Tooltip>\n          ))}\n        </Box>\n        \n        <Divider orientation=\"vertical\" flexItem />\n        \n        {/* Indicators */}\n        <Button\n          size=\"small\"\n          startIcon={<Insights />}\n          onClick={(e) => setIndicatorsMenuAnchor(e.currentTarget)}\n        >\n          Indicators\n        </Button>\n        \n        {/* Annotation Tools */}\n        {allowAnnotations && (\n          <Box sx={{ display: 'flex', gap: 0.5 }}>\n            {annotationTools.slice(0, 3).map(tool => (\n              <Tooltip key={tool.id} title={tool.name}>\n                <IconButton\n                  size=\"small\"\n                  color={annotationMode === tool.id ? 'primary' : 'default'}\n                  onClick={() => handleAnnotationClick(tool.id)}\n                >\n                  {tool.icon}\n                </IconButton>\n              </Tooltip>\n            ))}\n          </Box>\n        )}\n        \n        <Box sx={{ flex: 1 }} />\n        \n        {/* Zoom Controls */}\n        <Box sx={{ display: 'flex', gap: 0.5 }}>\n          <IconButton size=\"small\" onClick={() => handleZoom('out')}>\n            <ZoomOut />\n          </IconButton>\n          <Chip label={`${Math.round(zoomLevel * 100)}%`} size=\"small\" />\n          <IconButton size=\"small\" onClick={() => handleZoom('in')}>\n            <ZoomIn />\n          </IconButton>\n        </Box>\n        \n        {/* Controls */}\n        <IconButton size=\"small\" onClick={handleFullscreen}>\n          {fullscreen ? <FullscreenExit /> : <Fullscreen />}\n        </IconButton>\n        \n        <IconButton size=\"small\" onClick={() => setSettingsOpen(true)}>\n          <Settings />\n        </IconButton>\n        \n        <IconButton size=\"small\" onClick={handleExport}>\n          <Download />\n        </IconButton>\n      </Box>\n    );\n  };\n  \n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n    >\n      <Card \n        sx={{ \n          height: fullscreen ? '100vh' : 'auto',\n          position: fullscreen ? 'fixed' : 'relative',\n          top: fullscreen ? 0 : 'auto',\n          left: fullscreen ? 0 : 'auto',\n          right: fullscreen ? 0 : 'auto',\n          bottom: fullscreen ? 0 : 'auto',\n          zIndex: fullscreen ? 9999 : 'auto',\n          borderRadius: fullscreen ? 0 : undefined\n        }}\n      >\n        {renderToolbar()}\n        \n        <CardContent sx={{ p: 2 }}>\n          {/* Main Chart */}\n          <Box ref={chartRef}>\n            {chartType === 'candlestick' && renderCandlestickChart()}\n            {chartType === 'line' && (\n              <ResponsiveContainer width=\"100%\" height={height}>\n                <LineChart data={chartData} onClick={handleChartClick}>\n                  <CartesianGrid strokeDasharray=\"3 3\" />\n                  <XAxis dataKey=\"date\" />\n                  <YAxis />\n                  <RechartsTooltip />\n                  <Line\n                    type=\"monotone\"\n                    dataKey=\"close\"\n                    stroke={theme.palette.primary.main}\n                    strokeWidth={2}\n                  />\n                </LineChart>\n              </ResponsiveContainer>\n            )}\n            {chartType === 'area' && (\n              <ResponsiveContainer width=\"100%\" height={height}>\n                <AreaChart data={chartData} onClick={handleChartClick}>\n                  <CartesianGrid strokeDasharray=\"3 3\" />\n                  <XAxis dataKey=\"date\" />\n                  <YAxis />\n                  <RechartsTooltip />\n                  <Area\n                    type=\"monotone\"\n                    dataKey=\"close\"\n                    stroke={theme.palette.primary.main}\n                    fill={alpha(theme.palette.primary.main, 0.3)}\n                  />\n                </AreaChart>\n              </ResponsiveContainer>\n            )}\n          </Box>\n          \n          {/* Sub-charts */}\n          {renderVolumeChart()}\n          {renderRSIChart()}\n          \n          {/* Chart Info */}\n          <Box sx={{ mt: 2, display: 'flex', gap: 2, flexWrap: 'wrap' }}>\n            {Object.entries(indicators).map(([key, enabled]) => {\n              if (!enabled || !availableIndicators[key]) return null;\n              return (\n                <Chip\n                  key={key}\n                  label={availableIndicators[key].name}\n                  size=\"small\"\n                  sx={{\n                    bgcolor: alpha(availableIndicators[key].color, 0.1),\n                    color: availableIndicators[key].color,\n                    border: `1px solid ${availableIndicators[key].color}`\n                  }}\n                  onDelete={() => handleIndicatorToggle(key)}\n                />\n              );\n            })}\n          </Box>\n        </CardContent>\n      </Card>\n      \n      {/* Indicators Menu */}\n      <Menu\n        anchorEl={indicatorsMenuAnchor}\n        open={Boolean(indicatorsMenuAnchor)}\n        onClose={() => setIndicatorsMenuAnchor(null)}\n        PaperProps={{ sx: { maxHeight: 300, width: 250 } }}\n      >\n        {Object.entries(availableIndicators).map(([key, indicator]) => (\n          <MenuItem key={key} onClick={() => handleIndicatorToggle(key)}>\n            <ListItemIcon>\n              <Checkbox checked={indicators[key]} />\n            </ListItemIcon>\n            <ListItemText primary={indicator.name} />\n          </MenuItem>\n        ))}\n      </Menu>\n      \n      {/* Settings Dialog */}\n      <Dialog\n        open={settingsOpen}\n        onClose={() => setSettingsOpen(false)}\n        maxWidth=\"sm\"\n        fullWidth\n      >\n        <DialogTitle>Chart Settings</DialogTitle>\n        <DialogContent>\n          <Grid container spacing={3} sx={{ mt: 1 }}>\n            <Grid item xs={12}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={chartSettings.gridLines}\n                    onChange={(e) => setChartSettings(prev => ({ ...prev, gridLines: e.target.checked }))}\n                  />\n                }\n                label=\"Show Grid Lines\"\n              />\n            </Grid>\n            \n            <Grid item xs={12}>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={chartSettings.crosshair}\n                    onChange={(e) => setChartSettings(prev => ({ ...prev, crosshair: e.target.checked }))}\n                  />\n                }\n                label=\"Show Crosshair\"\n              />\n            </Grid>\n            \n            <Grid item xs={12}>\n              <Typography variant=\"subtitle2\" sx={{ mb: 1 }}>\n                Volume Panel Height (%)\n              </Typography>\n              <Slider\n                value={chartSettings.volumeHeight}\n                onChange={(e, value) => setChartSettings(prev => ({ ...prev, volumeHeight: value }))}\n                min={10}\n                max={40}\n                marks\n                valueLabelDisplay=\"auto\"\n              />\n            </Grid>\n          </Grid>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setSettingsOpen(false)}>Cancel</Button>\n          <Button variant=\"contained\" onClick={() => setSettingsOpen(false)}>\n            Apply\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </motion.div>\n  );\n};\n\nexport default AdvancedTradingChart;